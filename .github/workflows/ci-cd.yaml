# .github/workflows/ci-cd.yml

name: Python CI/CD Pipeline

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

permissions:
  contents: write

jobs:
  # ----------------------------------------------------
  # 1. Test, Lint, and Build Job (Runs for all matrix versions)
  # ----------------------------------------------------
  test_and_build:
    name: "Test, Lint, and Build"
    runs-on: ubuntu-latest
    
    # Define the matrix for multi-version testing
    strategy:
      fail-fast: false # Allows other versions to finish testing even if one fails
      matrix:
        python-version: ["3.12", "3.13", "3.14"]
        
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
          cache: 'pip'

      - name: Install Dependencies
        run: |
          python -m pip install --upgrade pip
          # Install all tools: pytest, coverage, ruff, mypy, bandit
          pip install pytest pytest-cov pytest-asyncio ruff mypy bandit build
          # Install the project itself (replace with your actual installation command)
          pip install -r requirements.txt
          # Install local lib
          pip install -e .

      # --- 1. Pytest and Coverage ---
      - name: Run Tests and Check Coverage
        run: |
          pytest --cov=bgetech_modbus --cov-report=xml

      # --- 2. Ruff (Linting & Formatting Check) ---
      - name: Run Ruff Linter and Formatter Check
        run: |
          ruff check .
          ruff format --check .

      # --- 3. MyPy (Static Type Checking) ---
      - name: Run MyPy Type Checker
        run: |
          mypy --install-types --non-interactive .

      # --- 4. Bandit (Security Scan) ---
      - name: Run Bandit Security Scan
        run: |
          bandit -r bgetech_modbus
          
      # The package build should only happen once, using the latest Python version
      - name: Build package (sdist and wheel)
        if: matrix.python-version == '3.14'
        run: python -m build
        
      # Upload artifacts only for the build generated by the latest Python version
      - name: Upload build artifacts
        if: matrix.python-version == '3.14'
        uses: actions/upload-artifact@v4
        with:
          name: package-dist
          path: dist/

 # ----------------------------------------------------
  # 2. PyPI Publish Job
  # ----------------------------------------------------
  publish_pypi:
    name: "Publish to PyPI"
    needs: test_and_build
    # Only run on push to main and if all tests passed
    if: success() && github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    environment: 
      name: pypi
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Full history needed for tag comparison

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: package-dist
          path: dist/
          
      - name: Check version change and set output variables
        id: check_version
        run: |
          # 1. Read current version from pyproject.toml
          # This command reads the 'version = "..."' line, extracts the number, and cleans it up.
          CURRENT_VERSION=$(grep '^\s*version\s*=' pyproject.toml | head -1 | sed -E 's/.*"([^"]+)".*/\1/')
          
          # 2. Get the latest release tag (vX.Y.Z)
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          
          NEW_TAG="v$CURRENT_VERSION"

          echo "Current Version in file: $CURRENT_VERSION"
          echo "Latest Git Tag: $LATEST_TAG"

          if [ "$NEW_TAG" == "$LATEST_TAG" ]; then
              echo "::notice file=pyproject.toml::Version $CURRENT_VERSION has not changed since $LATEST_TAG. Skipping deployment."
              # Set output to be empty if no change
              echo "new_tag=" >> $GITHUB_OUTPUT 
          else
              echo "::notice file=pyproject.toml::New version detected: $NEW_TAG. Proceeding with deployment."
              # Set output with the new tag
              echo "new_tag=$NEW_TAG" >> $GITHUB_OUTPUT
              
              # Set an environment variable for the next steps
              echo "VERSION_CHANGE=true" >> $GITHUB_ENV 
              echo "NEW_TAG_VAR=$NEW_TAG" >> $GITHUB_ENV
          fi
          
      - name: Publish to PyPI
        # Only run if the environment variable VERSION_CHANGE is true
        if: env.VERSION_CHANGE == 'true'
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          user: __token__
          password: ${{ secrets.PYPI_TOKEN }}
          packages_dir: dist

      - name: Create Git Tag
        # Only create tag if upload was successful (or if we skipped the upload, but we want the tag later)
        # Using the output variable from the version check step
        if: env.VERSION_CHANGE == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const newTag = process.env.NEW_TAG_VAR;
            await github.rest.git.createRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: `refs/tags/${newTag}`,
              sha: context.sha
            });
            console.log(`Tag ${newTag} created.`);
        env:
          NEW_TAG_VAR: ${{ env.NEW_TAG_VAR }} # Pass the variable to the script

  # ----------------------------------------------------
  # 3. GitHub Release Job
  # ----------------------------------------------------
  create_release:
    name: "Create GitHub Release"
    needs: publish_pypi
    # Only run if publish_pypi was successfully initiated (i.e. version changed)
    # This relies on the environment variable set in the previous job
    if: success() && github.event_name == 'push' && github.ref == 'refs/heads/main' && github.event.ref_name == 'main'
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Re-fetch the tag name created in the previous job for use in the release
      - name: Get Tag Name from Git
        id: get_tag
        run: |
          # Get the very latest tag that was just pushed by the previous job
          TAG=$(git describe --tags --abbrev=0)
          echo "NEW_TAG_VAR=$TAG" >> $GITHUB_ENV

      - name: Get Tag Name and Check Prerelease Status
        id: tag_check
        run: |
          # Den aktuellsten Tag abrufen, der gerade von Job 2 erstellt wurde
          TAG=$(git describe --tags --abbrev=0 2>/dev/null)
          
          # Sicherstellen, dass ein Tag existiert
          if [ -z "$TAG" ]; then
            echo "NEW_TAG_VAR=" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          VERSION=${TAG#v} # Führendes 'v' entfernen
          
          # Prüfen, ob die Version 'b' (beta) oder 'rc' (release candidate) enthält
          if [[ "$VERSION" =~ (b|rc) ]]; then
            IS_PRERELEASE=true
          else
            IS_PRERELEASE=false
          fi
          
          echo "NEW_TAG_VAR=$TAG" >> $GITHUB_OUTPUT
          echo "IS_PRERELEASE=$IS_PRERELEASE" >> $GITHUB_OUTPUT

      - name: Create GitHub Release
        if: steps.tag_check.outputs.NEW_TAG_VAR
        uses: softprops/action-gh-release@v2
        with:
          generate_release_notes: true 
          
          tag_name: ${{ steps.tag_check.outputs.NEW_TAG_VAR }}
          name: Release ${{ steps.tag_check.outputs.NEW_TAG_VAR }}
          draft: false
          prerelease: ${{ steps.tag_check.outputs.IS_PRERELEASE }}