# .github/workflows/ci-cd.yml

name: Python CI/CD Pipeline

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  # ----------------------------------------------------
  # 1. Test, Lint, and Build Job (Runs for all matrix versions)
  # ----------------------------------------------------
  test_and_build:
    runs-on: ubuntu-latest
    
    # Define the matrix for multi-version testing
    strategy:
      fail-fast: false # Allows other versions to finish testing even if one fails
      matrix:
        python-version: ["3.12", "3.13", "3.14"]
        
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
          cache: 'pip'

      - name: Install Dependencies
        run: |
          python -m pip install --upgrade pip
          # Install all tools: pytest, coverage, ruff, mypy, bandit
          pip install pytest pytest-cov pytest-asyncio ruff mypy bandit build
          # Install the project itself (replace with your actual installation command)
          pip install -r requirements.txt
          # Install local lib
          pip install -e .

      # --- 1. Pytest and Coverage ---
      - name: Run Tests and Check Coverage
        run: |
          pytest --cov=bgetech_modbus --cov-report=xml

      # --- 2. Ruff (Linting & Formatting Check) ---
      - name: Run Ruff Linter and Formatter Check
        run: |
          ruff check .
          ruff format --check .

      # --- 3. MyPy (Static Type Checking) ---
      - name: Run MyPy Type Checker
        run: |
          mypy --install-types --non-interactive .

      # --- 4. Bandit (Security Scan) ---
      - name: Run Bandit Security Scan
        run: |
          bandit -r bgetech_modbus
          
      # The package build should only happen once, using the latest Python version
      - name: Build package (sdist and wheel)
        if: matrix.python-version == '3.14'
        run: python -m build
        
      # Upload artifacts only for the build generated by the latest Python version
      - name: Upload build artifacts
        if: matrix.python-version == '3.14'
        uses: actions/upload-artifact@v4
        with:
          name: package-dist
          path: dist/

 # ----------------------------------------------------
  # 2. PyPI Publish Job
  # ----------------------------------------------------
  publish_pypi:
    needs: test_and_build
    # Only run on push to main and if all tests passed
    if: success() && github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    environment: 
      name: pypi
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Full history needed for tag comparison

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: package-dist
          path: dist/
          
      - name: Check version change and set output variables
        id: check_version
        run: |
          # 1. Read current version from pyproject.toml
          # This command reads the 'version = "..."' line, extracts the number, and cleans it up.
          CURRENT_VERSION=$(grep '^\s*version\s*=' pyproject.toml | head -1 | sed -E 's/.*"([^"]+)".*/\1/')
          
          # 2. Get the latest release tag (vX.Y.Z)
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          
          NEW_TAG="v$CURRENT_VERSION"

          echo "Current Version in file: $CURRENT_VERSION"
          echo "Latest Git Tag: $LATEST_TAG"

          if [ "$NEW_TAG" == "$LATEST_TAG" ]; then
              echo "::notice file=pyproject.toml::Version $CURRENT_VERSION has not changed since $LATEST_TAG. Skipping deployment."
              # Set output to be empty if no change
              echo "new_tag=" >> $GITHUB_OUTPUT 
          else
              echo "::notice file=pyproject.toml::New version detected: $NEW_TAG. Proceeding with deployment."
              # Set output with the new tag
              echo "new_tag=$NEW_TAG" >> $GITHUB_OUTPUT
              
              # Set an environment variable for the next steps
              echo "VERSION_CHANGE=true" >> $GITHUB_ENV 
              echo "NEW_TAG_VAR=$NEW_TAG" >> $GITHUB_ENV
          fi
          
      - name: Publish to PyPI
        # Only run if the environment variable VERSION_CHANGE is true
        if: env.VERSION_CHANGE == 'true'
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          password: ${{ secrets.PYPI_API_TOKEN }} 
          
      - name: Create Git Tag
        # Only create tag if upload was successful (or if we skipped the upload, but we want the tag later)
        # Using the output variable from the version check step
        if: env.VERSION_CHANGE == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const newTag = process.env.NEW_TAG_VAR;
            await github.rest.git.createRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: `refs/tags/${newTag}`,
              sha: context.sha
            });
            console.log(`Tag ${newTag} created.`);
        env:
          NEW_TAG_VAR: ${{ env.NEW_TAG_VAR }} # Pass the variable to the script

  # ----------------------------------------------------
  # 3. GitHub Release Job
  # ----------------------------------------------------
  create_release:
    needs: publish_pypi
    # Only run if publish_pypi was successfully initiated (i.e. version changed)
    # This relies on the environment variable set in the previous job
    if: success() && github.event_name == 'push' && github.ref == 'refs/heads/main' && github.event.ref_name == 'main'
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Re-fetch the tag name created in the previous job for use in the release
      - name: Get Tag Name from Git
        id: get_tag
        run: |
          # Get the very latest tag that was just pushed by the previous job
          TAG=$(git describe --tags --abbrev=0)
          echo "NEW_TAG_VAR=$TAG" >> $GITHUB_ENV

      - name: Generate Changelog (Simulating GitHub UI functionality)
        id: changelog
        if: env.NEW_TAG_VAR # Only if a tag was found
        # ðŸ’¡ This is the best community action to simulate the "Generate release notes" button
        uses: "amannn/action-generate-release-notes@v1" 
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          template: default.hbs 
          
      - name: Create GitHub Release
        if: env.NEW_TAG_VAR # Only if a tag was found
        # ðŸ’¡ The softprops action is the most versatile for creating the release with a custom body
        uses: softprops/action-gh-release@v2 
        with:
          tag_name: ${{ env.NEW_TAG_VAR }}
          name: Release ${{ env.NEW_TAG_VAR }}
          body: ${{ steps.changelog.outputs.body }} # Passing the generated notes here
          draft: false
          prerelease: false